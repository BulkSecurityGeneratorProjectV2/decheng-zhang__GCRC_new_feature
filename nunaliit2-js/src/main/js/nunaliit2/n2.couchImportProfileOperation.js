/*
Copyright (c) 2017, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($n2) {
"use strict";

/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var importProfileOperation = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,9],$V1=[1,14],$V2=[1,15],$V3=[1,16],$V4=[1,27],$V5=[1,26],$V6=[1,35],$V7=[1,40],$V8=[1,34],$V9=[1,37],$Va=[1,38],$Vb=[1,39],$Vc=[1,41],$Vd=[1,45],$Ve=[1,46],$Vf=[1,47],$Vg=[1,48],$Vh=[1,49],$Vi=[1,50],$Vj=[1,51],$Vk=[1,52],$Vl=[1,53],$Vm=[1,54],$Vn=[1,55],$Vo=[1,56],$Vp=[1,57],$Vq=[9,11,20,21,23,24,25,26,27,28,34,35,36,37,38,42],$Vr=[7,9,11,20,21,23,24,25,26,27,28,34,35,36,37,38,39,41,42],$Vs=[9,11,20,21,42],$Vt=[9,11,20,21,23,24,25,26,27,28,42],$Vu=[9,11,20,21,23,24,25,26,27,28,34,35,42];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"program":3,"operation":4,"EOF":5,"OP_ASSIGN_REFERENCE":6,"(":7,"objectSelector":8,",":9,"referenceSelector":10,")":11,"OP_ASSIGN_REFERENCES":12,"REF_FROM_SCHEMA":13,"STRING":14,"valueSelector":15,"REF_FROM_SCHEMA2":16,"value":17,"REF_FROM_VALUE":18,"IMPORTED_ATTRIBUTE":19,"&&":20,"||":21,"!":22,"==":23,"!=":24,">=":25,"<=":26,">":27,"<":28,"identifier":29,"arguments":30,"true":31,"false":32,"NUMBER":33,"+":34,"-":35,"*":36,"/":37,"%":38,".":39,"VAR_NAME":40,"[":41,"]":42,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"OP_ASSIGN_REFERENCE",7:"(",9:",",11:")",12:"OP_ASSIGN_REFERENCES",13:"REF_FROM_SCHEMA",14:"STRING",16:"REF_FROM_SCHEMA2",18:"REF_FROM_VALUE",19:"IMPORTED_ATTRIBUTE",20:"&&",21:"||",22:"!",23:"==",24:"!=",25:">=",26:"<=",27:">",28:"<",31:"true",32:"false",33:"NUMBER",34:"+",35:"-",36:"*",37:"/",38:"%",39:".",40:"VAR_NAME",41:"[",42:"]"},
productions_: [0,[3,2],[4,6],[4,6],[10,8],[10,6],[10,4],[15,4],[15,1],[8,1],[17,3],[17,3],[17,2],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,4],[17,1],[17,1],[17,1],[17,1],[17,1],[17,3],[17,3],[17,3],[17,3],[17,3],[30,3],[30,1],[29,3],[29,4],[29,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2:

        	this.$ = new OpAssignReference($$[$0-3],$$[$0-1]);
        
break;
case 3:

        	this.$ = new OpAssignReferences($$[$0-3],$$[$0-1]);
        
break;
case 4:

        	this.$ = new RefFromSchema($$[$0-5],$$[$0-3],$$[$0-1]);
        
break;
case 5:

        	this.$ = new RefFromSchema2($$[$0-3],$$[$0-1]);
        
break;
case 6:

        	this.$ = new RefFromValue($$[$0-1]);
        
break;
case 7:

        	this.$ = new ImportedAttributeValue($$[$0-1]);
        
break;
case 8:

        	this.$ = new StringValue($$[$0]);
        
break;
case 9:

        	this.$ = new ObjectSelector2($$[$0]);
        
break;
case 10:

        	this.$ = new Expression($$[$0-2],'&&',$$[$0]);
        
break;
case 11:

        	this.$ = new Expression($$[$0-2],'||',$$[$0]);
        
break;
case 12:

        	this.$ = new Expression($$[$0],'!');
        
break;
case 13:

    		this.$ = $$[$0-1];
    	
break;
case 14:

        	this.$ = new Comparison($$[$0-2],$$[$0],'==');
        
break;
case 15:

        	this.$ = new Comparison($$[$0-2],$$[$0],'!=');
        
break;
case 16:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>=');
        
break;
case 17:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<=');
        
break;
case 18:

        	this.$ = new Comparison($$[$0-2],$$[$0],'>');
        
break;
case 19:

        	this.$ = new Comparison($$[$0-2],$$[$0],'<');
        
break;
case 20:

        	this.$ = new FunctionCall($$[$0-2],null);
        
break;
case 21:

        	this.$ = new FunctionCall($$[$0-3],$$[$0-1]);
        
break;
case 22:

        	this.$ = $$[$0];
        
break;
case 23:

    		this.$ = new Literal(true);
    	
break;
case 24:

    		this.$ = new Literal(false);
    	
break;
case 25:

    		this.$ = new Literal(1 * $$[$0]);
    	
break;
case 26:

    		this.$ = new Literal($$[$0]);
    	
break;
case 27:

    		this.$ = new MathOp($$[$0-2],$$[$0],'+');
    	
break;
case 28:

    		this.$ = new MathOp($$[$0-2],$$[$0],'-');
    	
break;
case 29:

    		this.$ = new MathOp($$[$0-2],$$[$0],'*');
    	
break;
case 30:

    		this.$ = new MathOp($$[$0-2],$$[$0],'/');
    	
break;
case 31:

    		this.$ = new MathOp($$[$0-2],$$[$0],'%');
    	
break;
case 32:

        	this.$ = new Argument($$[$0-2],$$[$0]);
        
break;
case 33:

        	this.$ = new Argument($$[$0]);
        
break;
case 34:

        	var id = new Literal($$[$0]);
        	this.$ = new ObjectSelector(id,$$[$0-2]);
        
break;
case 35:

        	this.$ = new ObjectSelector($$[$0-1],$$[$0-3]);
        
break;
case 36:

        	this.$ = new Variable($$[$0]);
        
break;
}
},
table: [{3:1,4:2,6:[1,3],12:[1,4]},{1:[3]},{5:[1,5]},{7:[1,6]},{7:[1,7]},{1:[2,1]},{8:8,14:$V0},{8:10,14:$V0},{9:[1,11]},{9:[2,9]},{9:[1,12]},{10:13,13:$V1,16:$V2,18:$V3},{10:17,13:$V1,16:$V2,18:$V3},{11:[1,18]},{7:[1,19]},{7:[1,20]},{7:[1,21]},{11:[1,22]},{5:[2,2]},{14:[1,23]},{14:[1,24]},{14:$V4,15:25,19:$V5},{5:[2,3]},{9:[1,28]},{9:[1,29]},{11:[1,30]},{7:[1,31]},{11:[2,8]},{8:32,14:$V0},{7:$V6,14:$V7,17:33,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{11:[2,6]},{14:[1,42]},{9:[1,43]},{11:[1,44],20:$Vd,21:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,28:$Vk,34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp},{7:$V6,14:$V7,17:58,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:59,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},o($Vq,[2,22],{7:[1,60],39:[1,61],41:[1,62]}),o($Vq,[2,23]),o($Vq,[2,24]),o($Vq,[2,25]),o($Vq,[2,26]),o($Vr,[2,36]),{11:[1,63]},{14:$V4,15:64,19:$V5},{11:[2,5]},{7:$V6,14:$V7,17:65,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:66,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:67,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:68,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:69,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:70,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:71,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:72,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:73,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:74,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:75,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:76,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{7:$V6,14:$V7,17:77,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},o($Vq,[2,12]),{11:[1,78],20:$Vd,21:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,28:$Vk,34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp},{7:$V6,11:[1,79],14:$V7,17:81,22:$V8,29:36,30:80,31:$V9,32:$Va,33:$Vb,40:$Vc},{40:[1,82]},{7:$V6,14:$V7,17:83,22:$V8,29:36,31:$V9,32:$Va,33:$Vb,40:$Vc},{11:[2,7]},{11:[1,84]},o($Vs,[2,10],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,28:$Vk,34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vs,[2,11],{23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,28:$Vk,34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vt,[2,14],{34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vt,[2,15],{34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vt,[2,16],{34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vt,[2,17],{34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vt,[2,18],{34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vt,[2,19],{34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp}),o($Vu,[2,27],{36:$Vn,37:$Vo,38:$Vp}),o($Vu,[2,28],{36:$Vn,37:$Vo,38:$Vp}),o($Vq,[2,29]),o($Vq,[2,30]),o($Vq,[2,31]),o($Vq,[2,13]),o($Vq,[2,20]),{11:[1,85]},{9:[1,86],11:[2,33],20:$Vd,21:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,28:$Vk,34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp},o($Vr,[2,34]),{20:$Vd,21:$Ve,23:$Vf,24:$Vg,25:$Vh,26:$Vi,27:$Vj,28:$Vk,34:$Vl,35:$Vm,36:$Vn,37:$Vo,38:$Vp,42:[1,87]},{11:[2,4]},o($Vq,[2,21]),{7:$V6,14:$V7,17:81,22:$V8,29:36,30:88,31:$V9,32:$Va,33:$Vb,40:$Vc},o($Vr,[2,35]),{11:[2,32]}],
defaultActions: {5:[2,1],9:[2,9],18:[2,2],22:[2,3],27:[2,8],30:[2,6],44:[2,5],63:[2,7],84:[2,4],88:[2,32]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
    function _parseError (msg, hash) {
        this.message = msg;
        this.hash = hash;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
//    return true;
}};


function compareReferences(ref1, ref2){
	if( ref1 === ref2 ) return 0; // null == null and undefined == undefined
	if( !ref1 ) return -1;
	if( !ref2 ) return 1;
	if( ref1.doc === ref2.doc ) return 0;
	if( typeof ref1.doc === 'undefined' || ref1.doc === null ) return -1; 
	if( typeof ref2.doc === 'undefined' || ref2.doc === null ) return 1;
	if( ref1.doc < ref2.doc ) return -1; 
	if( ref1.doc > ref2.doc ) return 1;
	return 0; 
};

function compareReferenceSets(set1, set2){
	if( set1 === set2 ) return 0; // null == null and undefined == undefined
	if( !set1 ) return -1;
	if( !set2 ) return 1;
	
	var map1 = {};
	set1.forEach(function(ref){
		if( ref
		 && typeof ref.doc === 'string' ){
			map1[ref.doc] = true;
		};
	});

	var map2 = {};
	set2.forEach(function(ref){
		if( ref
		 && typeof ref.doc === 'string' ){
			map2[ref.doc] = true;
		};
	});
	
	for(var docId in map1){
		if( !map2[docId] ){
			return -1;
		};
	};

	for(var docId in map2){
		if( !map1[docId] ){
			return 1;
		};
	};

	return 0; 
};

// Functions in the global space receives the context object
// as 'this'.
var global = {
};
parser.global = global;

// -----------------------------------------------------------
var OpAssignReference = function(objectSelector, referenceSelector){
	this.targetSelector = objectSelector;
	this.referenceSelector = referenceSelector;
};
OpAssignReference.prototype.configure = function(opts){
	if( this.targetSelector 
	 && typeof this.targetSelector.configure === 'function' ){
	 	this.targetSelector.configure(opts);
	};
	if( this.referenceSelector 
	 && typeof this.referenceSelector.configure === 'function' ){
	 	this.referenceSelector.configure(opts);
	};
};
OpAssignReference.prototype.reportCopyOperations = function(opts){

	var propertyNameMap = {};
	var computedValues = this.referenceSelector.getValues(opts, propertyNameMap);
	
	// create new value
	var updatedValue = undefined;
	if( computedValues.length === 1 ){
		updatedValue = computedValues[0];
	} else if( computedValues.length > 1 ){
		throw new Error('Multiple references found for a single unit');
	};

	var targetValue = this.targetSelector.getValue(opts.doc);
	
	var isInconsistent = false;
	if( 0 !== compareReferences(targetValue, updatedValue) ){
		isInconsistent = true;
	};

	var inputPropertyNames = [];
	for(var propertyName in propertyNameMap){
		inputPropertyNames.push(propertyName);
	};

	var op = {
		propertyNames: inputPropertyNames
		,computedValue: updatedValue
		,targetSelector: this.targetSelector
		,targetValue: targetValue
		,isInconsistent: isInconsistent
	};	

	opts.onSuccess([op]);
};
OpAssignReference.prototype.performCopyOperation = function(opts_){
	var opts = $n2.extend({
		doc: null
		,importData: null
		,copyOperation: null
	},opts_);
	
	var doc = opts.doc;
	
	var computedValues = this.referenceSelector.getValues(opts, {});
	if( computedValues.length > 1 ){
		throw new Error('Multiple references returned for a single unit');
	};
	var importValue = undefined;
	if( computedValues.length > 0 ){
		importValue = computedValues[0];
	};

	if( typeof importValue === 'undefined' ){
		// Must delete
		this.targetSelector.removeValue(doc);
	} else {
		this.targetSelector.setValue(doc, importValue);
	};
};

// -----------------------------------------------------------
var OpAssignReferences = function(objectSelector, referenceSelector){
	this.targetSelector = objectSelector;
	this.referenceSelector = referenceSelector;
};
OpAssignReferences.prototype.configure = function(opts){
	if( this.targetSelector 
	 && typeof this.targetSelector.configure === 'function' ){
	 	this.targetSelector.configure(opts);
	};
	if( this.referenceSelector 
	 && typeof this.referenceSelector.configure === 'function' ){
	 	this.referenceSelector.configure(opts);
	};
};
OpAssignReferences.prototype.reportCopyOperations = function(opts){

	var propertyNameMap = {};
	var computedReferences = this.referenceSelector.getValues(opts, propertyNameMap);
	
	var currentReferences = this.targetSelector.getValue(opts.doc);
	
	var isInconsistent = false;
	if( 0 !== compareReferenceSets(currentReferences, computedReferences) ){
		isInconsistent = true;
	};

	var inputPropertyNames = [];
	for(var propertyName in propertyNameMap){
		inputPropertyNames.push(propertyName);
	};

	var op = {
		propertyNames: inputPropertyNames
		,computedValue: computedReferences
		,targetSelector: this.targetSelector
		,targetValue: currentReferences
		,isInconsistent: isInconsistent
	};	

	opts.onSuccess([op]);
};
OpAssignReferences.prototype.performCopyOperation = function(opts_){
	var opts = $n2.extend({
		doc: null
		,importData: null
		,copyOperation: null
	},opts_);
	
	var doc = opts.doc;
	
	var computedValues = this.referenceSelector.getValues(opts, {});

	this.targetSelector.setValue(doc, computedValues);
};

// -----------------------------------------------------------
var StringValue = function(value){
	this.value = value;
};
StringValue.prototype.configure = function(opts){
};
StringValue.prototype.getValues = function(opts, propertyNameMap){
	if( typeof this.value === 'string' ){
		return [this.value];
	};

	return [];
};

// -----------------------------------------------------------
var ImportedAttributeValue = function(targetSelector){
	if( typeof targetSelector === 'string' ){
		this.targetSelector = $n2.objectSelector.parseSelector(targetSelector);
	} else {
		throw new Error('expected a string');
	};
};
ImportedAttributeValue.prototype.configure = function(opts){
	if( this.targetSelector 
	 && typeof this.targetSelector.configure === 'function' ){
	 	this.targetSelector.configure(opts);
	};
};
ImportedAttributeValue.prototype.getValues = function(opts, propertyNameMap){
	// Returns an array of values found in the import data
	var targetValue = this.targetSelector.getValue(opts.importData);
	
	if( targetValue === undefined ){
		return [];
	};

	var propName = this.targetSelector.getSelectorString();
	propertyNameMap[propName] = true;
	
	return [targetValue];
};

// -----------------------------------------------------------
// schemaName - String that represents a schema name
// objectSelector - Object selector
// valueSelector - Value selector
var RefFromSchema = function(schemaName, objectSelector, valueSelector){
	this.schemaName = schemaName;
	this.objectSelector = objectSelector;
	this.valueSelector = valueSelector;

	this.documents = [];
};
RefFromSchema.prototype.configure = function(opts){
	var _this = this;

	if( this.schemaName 
	 && typeof this.schemaName.configure === 'function' ){
	 	this.schemaName.configure(opts);
	};
	if( this.objectSelector 
	 && typeof this.objectSelector.configure === 'function' ){
	 	this.objectSelector.configure(opts);
	};
	if( this.valueSelector 
	 && typeof this.valueSelector.configure === 'function' ){
	 	this.valueSelector.configure(opts);
	};
	
	if( opts.atlasDesign ){
		opts.atlasDesign.queryView({
			viewName: 'nunaliit-schema'
			,startkey: this.schemaName
			,endkey: this.schemaName
			,include_docs: true
			,onSuccess: function(rows){
				rows.forEach(function(row){
					var doc = row.doc;
					_this.documents.push(doc);
				});
			}
		});
	};
};
RefFromSchema.prototype.getValues = function(opts, propertyNameMap){
	var _this = this;

	var values = this.valueSelector.getValues(opts, propertyNameMap);
	
	// Select documents
	var selectedDocuments = [];
	this.documents.forEach(function(doc){
		var selected = false;
		
		var v = _this.objectSelector.getValue(doc);
		values.forEach(function(value){
			if( v === value ){
				selected = true;
			};
		});
		
		if( selected ){
			selectedDocuments.push(doc);
		};
	});

	// Returns an array of references based on the selected keys
	var references = [];
	selectedDocuments.forEach(function(doc){
		var ref = {
			nunaliit_type: 'reference'
			,doc: doc._id
		};
		references.push(ref);
	});

	return references;
};

// -----------------------------------------------------------
// schemaName - String that represents a schema name
// value - Value selector
var RefFromSchema2 = function(schemaName, value){
	this.schemaName = schemaName;
	this.value = value;

	this.documents = [];
};
RefFromSchema2.prototype.configure = function(opts){
	var _this = this;

	if( this.schemaName 
	 && typeof this.schemaName.configure === 'function' ){
	 	this.schemaName.configure(opts);
	};
	if( this.value 
	 && typeof this.value.configure === 'function' ){
	 	this.value.configure(opts);
	};
	
	if( opts.atlasDesign ){
		opts.atlasDesign.queryView({
			viewName: 'nunaliit-schema'
			,startkey: this.schemaName
			,endkey: this.schemaName
			,include_docs: true
			,onSuccess: function(rows){
				rows.forEach(function(row){
					var doc = row.doc;
					_this.documents.push(doc);
				});
			}
		});
	};
};
RefFromSchema2.prototype.getValues = function(opts, propertyNameMap){
	var _this = this;

	// Select documents
	var selectedDocuments = [];
	this.documents.forEach(function(doc){
		var ctxt = {};
		ctxt.n2_doc = opts.doc;
		ctxt['import'] = opts.importData;
		
		var v = _this.value.getValue(ctxt);
		
		if( v ){
			selectedDocuments.push(doc);
		};
	});

	// Returns an array of references based on the selected keys
	var references = [];
	selectedDocuments.forEach(function(doc){
		var ref = {
			nunaliit_type: 'reference'
			,doc: doc._id
		};
		references.push(ref);
	});

	return references;
};

// -----------------------------------------------------------
var RefFromValue = function(valueSelector){
	this.valueSelector = valueSelector;
};
RefFromValue.prototype.configure = function(opts){
	if( this.valueSelector 
	 && typeof this.valueSelector.configure === 'function' ){
	 	this.valueSelector.configure(opts);
	};
};
RefFromValue.prototype.getValues = function(opts, propertyNameMap){
	// Returns an array of references based on the selected keys
	var values = this.valueSelector.getValues(opts, propertyNameMap);

	// Returns an array of references based on the selected keys
	var references = [];
	values.forEach(function(value){
		var ref = {
			nunaliit_type: 'reference'
			,doc: value
		};
		references.push(ref);
	});

	return references;
};

// -----------------------------------------------------------
// selectorStr - Dotted notation for an object selector
var ObjectSelector2 = function(selectorStr){
	this.selectorStr = selectorStr;
	this.selector = $n2.objectSelector.parseSelector(selectorStr);
};
ObjectSelector2.prototype.configure = function(opts){
};
ObjectSelector2.prototype.getValue = function(obj){
	return this.selector.getValue(obj);
};
ObjectSelector2.prototype.setValue = function(obj, value){
	this.selector.setValue(obj, value, true);
};
ObjectSelector2.prototype.removeValue = function(obj){
	this.selector.removeValue(obj);
};

// -----------------------------------------------------------
var FunctionCall = function(value, args){
	this.value = value;
	this.args = args;
};
FunctionCall.prototype.getValue = function(ctxt){
	var value = this.value.getValue(ctxt);
	if( typeof value === 'function' ){
		var args = [];
		if( this.args ){
			this.args.pushOnArray(ctxt, args);
		};
		return value.apply(ctxt, args);
	};
	return false;
};

// -----------------------------------------------------------
// Argument
var Argument = function(a1, a2){
	this.valueNode = a1;
	if( a2 ){
		this.nextArgument = a2;
	} else {
		this.nextArgument = null;
	};
};
Argument.prototype.getCount = function(){
	if( this.nextArgument ){
		return 1 + this.nextArgument.getCount();
	};
	
	return 1;
};
Argument.prototype.getArgument = function(ctxt, position){
	if( position < 1 ){
		return this.valueNode.getValue(ctxt);
	};
	
	if( this.nextArgument ){
		this.nextArgument.getArgument(ctxt, position-1);
	};
	
	return undefined;
};
Argument.prototype.pushOnArray = function(ctxt, array){
	var value = this.valueNode.getValue(ctxt);
	array.push(value);
	
	if( this.nextArgument ){
		this.nextArgument.pushOnArray(ctxt, array);
	};
};

// -----------------------------------------------------------
var Expression = function(n1, op, n2){
	this.n1 = n1;
	this.n2 = n2;
	this.op = op;
};
Expression.prototype.getValue = function(ctxt){
	var r1 = this.n1.getValue(ctxt);
	var r2 = undefined;
	if( this.n2 ){
		r2 = this.n2.getValue(ctxt);
	};
	if( '!' === this.op ){
		return !r1;
		
	} else if( '&&' === this.op ){
		return (r1 && r2);
		
	} else if( '||' === this.op ){
		return (r1 || r2);
	};
	return false;
};

// -----------------------------------------------------------
var Literal = function(value){
	this.value = value;
};
Literal.prototype.getValue = function(ctxt){
	return this.value;
};

// -----------------------------------------------------------
var Comparison = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
Comparison.prototype.getValue = function(ctxt){
	var left = this.leftNode.getValue(ctxt);
	var right = this.rightNode.getValue(ctxt);

	if( '==' === this.op ){
		return (left == right);

	} else if( '!=' === this.op ){
		return (left != right);

	} else if( '>=' === this.op ){
		return (left >= right);

	} else if( '<=' === this.op ){
		return (left <= right);

	} else if( '>' === this.op ){
		return (left > right);

	} else if( '<' === this.op ){
		return (left < right);
	};
	
	return false;
};

// -----------------------------------------------------------
var MathOp = function(leftNode, rightNode, op){
	this.leftNode = leftNode;
	this.rightNode = rightNode;
	this.op = op;
};
MathOp.prototype.getValue = function(ctxt){
	var left = this.leftNode.getValue(ctxt);
	var right = this.rightNode.getValue(ctxt);

	if( '+' === this.op ){
		return (left + right);

	} else if( '-' === this.op ){
		return (left - right);

	} else if( '*' === this.op ){
		return (left * right);

	} else if( '/' === this.op ){
		return (left / right);

	} else if( '%' === this.op ){
		return (left % right);
	};
	
	return 0;
};

// -----------------------------------------------------------
var ObjectSelector = function(id, previousSelector){
	this.idNode = id;
	this.previousSelector = previousSelector;
};
ObjectSelector.prototype.getValue = function(ctxt){
	var obj = this.previousSelector.getValue(ctxt);
	if( typeof obj === 'object' ){
		var id = this.idNode.getValue(ctxt);
		if( typeof id === 'undefined' ){
			return undefined;
		};
		
		return obj[id];
	};

	return undefined;
};

// -----------------------------------------------------------
var Variable = function(variableName){
	this.variableName = variableName;
};
Variable.prototype.getValue = function(ctxt){
	var obj = undefined;
	
	if( ctxt && 'doc' === this.variableName ) {
		obj = ctxt.n2_doc;
		
	} else if( ctxt && ctxt[this.variableName] ) {
		obj = ctxt[this.variableName];
		
	} else if( global && global[this.variableName] ) {
		obj = global[this.variableName];
	};
	
	return obj;
};


/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: /* skip whitespace */ 
break;
case 1: return 31; 
break;
case 2: return 32; 
break;
case 3: return 6; 
break;
case 4: return 12; 
break;
case 5: return 19; 
break;
case 6: return 13; 
break;
case 7: return 16; 
break;
case 8: return 18; 
break;
case 9: return 33; 
break;
case 10: return 40; 
break;
case 11: yy_.yytext = yy_.yytext.substr(1,yy_.yytext.length-2); return 14; 
break;
case 12: return 23; 
break;
case 13: return 24; 
break;
case 14: return 25; 
break;
case 15: return 26; 
break;
case 16: return 27; 
break;
case 17: return 28; 
break;
case 18: return 7; 
break;
case 19: return 11; 
break;
case 20: return '{'; 
break;
case 21: return '}'; 
break;
case 22: return 41; 
break;
case 23: return 42; 
break;
case 24: return 9; 
break;
case 25: return 39; 
break;
case 26: return 22; 
break;
case 27: return 34; 
break;
case 28: return 35; 
break;
case 29: return 36; 
break;
case 30: return 37; 
break;
case 31: return 38; 
break;
case 32: return 20; 
break;
case 33: return 21; 
break;
case 34: return 5; 
break;
case 35: return 'INVALID'; 
break;
}
},
rules: [/^(?:\s+)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:assignReference\b)/,/^(?:assignReferences\b)/,/^(?:importedAttribute\b)/,/^(?:fromSchema\b)/,/^(?:fromSchema2\b)/,/^(?:referencesFromValue\b)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:[_a-zA-Z][_a-zA-Z0-9]*)/,/^(?:'(\\'|[^'])*')/,/^(?:==)/,/^(?:!=)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:\()/,/^(?:\))/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?:\.)/,/^(?:!)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = importProfileOperation;
exports.Parser = importProfileOperation.Parser;
exports.parse = function () { return importProfileOperation.parse.apply(importProfileOperation, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}	
//--------------------------------------------------------------------------
function parse(){
	return importProfileOperation.parse.apply(importProfileOperation, arguments);
};

//--------------------------------------------------------------------------
function getGlobalContext(){
	return importProfileOperation.global;
};
	
//--------------------------------------------------------------------------
$n2.importProfileOperation = {
	parse: parse
	,getGlobalContext: getGlobalContext
};

})(nunaliit2);
